(ns fractl.lang.opcode
  "Abstractions to deal with opcodes generated by the compiler.")

(def arg :arg)
(def op :op)

(defn make-opcode [tag x]
  {op tag
   arg x})

(defn op? [tag opc]
  (= (op opc) tag))

(defmacro defopcode [opc]
  (let [kw (keyword (name opc))]
    `(do (def ~opc (partial make-opcode ~kw))
         (def ~(symbol (str (name opc) "?")) (partial op? ~kw)))))

(defn- dispatcher [n]
  (symbol (str "do-" (name n))))

(defmacro defvm [opc-names-args]
  (let [nargs (map (fn [[n args docstring]]
                     `(~(dispatcher n) ~(vec (concat ['--self-- '--env--] args)) docstring))
                   opc-names-args)
        opcdefs (map (fn [[n _ _]]
                       `(defopcode ~n))
                     opc-names-args)
        dispatch-table (into {} (map (fn [[n _ _ ]]
                                       [(keyword (name n)) (dispatcher n)])
                                     opc-names-args))]
    `(do (defprotocol VM ~@nargs)
         ~@opcdefs
         (def dispatch-table ~dispatch-table))))

;; The virtual machine for evaluating dataflows.
;; Declares the instruction-set (opcodes), defines a protocol for
;; handling these instructions and initializes a dispatch table for
;; the handler methods. Each method corresponds to an opcode.
;;
;; The argument list of the new protocol will be extended to receive
;; a reference to self and the runtime environment. Also the `do-` prefix
;; will be added to the method names. For example, the method
;; `(match-instance [pattern instance])` will become `(do-match-instance [self env pattern instance])`.
;; A resolver is an implementation of this newly defined protocol.
;;
;; The dispatch table will have the structure {:match-instance match-instance ...}.
;; If someone has an opcode, its keyword mnemonic can be fetched with a call to the
;; `op` function. The corresponding handler can be looked-up in the dispatch table
;; using this mnemonic and called with an appropriate resolver implementation.
(defvm [(match-instance
         [[pattern instance]]
         "If the instance matches the pattern, update env with the instance. Return {:result true}.
          If there is no match, return {:result false}.")
        (load-instance
         [record-name]
         "Load an instance from the environment. The resolver may extend the search to a database backend, then
          env must be updated with the loaded instance.")
        (load-references
         [[record-name refs]]
         "Update env with referenced instances.")
        (new-instance
         [record-name]
         "Start initializing a record/entity/event instance.")
        (query-instance
         [[entity-name query-attrs]]
         "Start initializing an entity instance in env by first querying it from a persistent store.")
        (set-literal-attribute
         [[attr-name attr-value]]
         "Set the attribute in the instance that is being inited to the given value.")
        (set-ref-attribute
         [[attr-name attr-ref]]
         "Set the attribute in the instance that is being inited by fetching a value from
          the reference.")
        (set-compound-attribute
         [[attr-name f]]
         "Set the attribute in the instance that is being inited by invoking the function.")
        (intern-instance
         [record-name]
         "Finish the instance initialization by intering that in env.")
        (intern-event-instance
         [record-name]
         "Finish the instance initialization of an event, evaluate attached dataflows.")])
